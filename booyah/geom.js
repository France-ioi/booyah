"use strict";
// Geometry
Object.defineProperty(exports, "__esModule", { value: true });
exports.EPSILON = 0.001;
exports.ZERO = new PIXI.Point(0, 0);
exports.ONE = new PIXI.Point(1, 1);
/** Returns a number for x that is between min and max */
function clamp(x, min, max) {
    return Math.min(max, Math.max(min, x));
}
exports.clamp = clamp;
/** Returns the vector length of a a PIXI Point */
function magnitude(a) {
    return Math.sqrt(a.x * a.x + a.y * a.y);
}
exports.magnitude = magnitude;
/** Returns a copy of the PIXI Point x that has a magnitude between min and max */
function clampMagnitude(a, min, max) {
    const mag = magnitude(a);
    if (mag < min) {
        return multiply(a, min / mag);
    }
    else if (mag > max) {
        return multiply(a, max / mag);
    }
    else {
        return a;
    }
}
exports.clampMagnitude = clampMagnitude;
/** Returns the distance between two PIXI Points */
function distance(a, b) {
    let x = a.x - b.x;
    let y = a.y - b.y;
    return Math.sqrt(x * x + y * y);
}
exports.distance = distance;
/** Linear interpolation between numbers a and b, using the fraction p */
function lerp(a, b, p) {
    return a + (b - a) * p;
}
exports.lerp = lerp;
/** Linear interpolation between points a and b, using the fraction p */
function lerpPoint(a, b, p) {
    const x = b.x - a.x;
    const y = b.y - a.y;
    return new PIXI.Point(a.x + p * x, a.y + p * y);
}
exports.lerpPoint = lerpPoint;
/** Linear interpolation between arrays a and b, using the fraction p */
function lerpArray(a, b, p) {
    const result = [];
    for (let i = 0; i < a.length; i++) {
        result.push(lerp(a[i], b[i], p));
    }
    return result;
}
exports.lerpArray = lerpArray;
/** Linear interpolation between RGB colors a and b, using the fraction p */
function lerpColor(a, b, p) {
    // Separate into 3 components
    const aComponents = [(a & 0xff0000) >> 16, (a & 0x00ff00) >> 8, a & 0x0000ff];
    const bComponents = [(b & 0xff0000) >> 16, (b & 0x00ff00) >> 8, b & 0x0000ff];
    return ((lerp(aComponents[0], bComponents[0], p) << 16) |
        (lerp(aComponents[1], bComponents[1], p) << 8) |
        lerp(aComponents[2], bComponents[2], p));
}
exports.lerpColor = lerpColor;
/**
 Find the direction around the circle that is shorter
 Based on https://stackoverflow.com/a/2007279
 */
function angleBetweenAngles(source, target) {
    return Math.atan2(Math.sin(target - source), Math.cos(target - source));
}
exports.angleBetweenAngles = angleBetweenAngles;
/** Linear interpolation between angles a and b, using fraction p */
function lerpAngle(a, b, p) {
    return a + p * angleBetweenAngles(a, b);
}
exports.lerpAngle = lerpAngle;
/** Returns a copy of a that is > 0 */
function makeAnglePositive(a) {
    while (a < 0)
        a += 2 * Math.PI;
    return a;
}
exports.makeAnglePositive = makeAnglePositive;
/** Normalizes an angle between -pi and pi */
function normalizeAngle(a) {
    while (a > Math.PI)
        a -= 2 * Math.PI;
    while (a < -Math.PI)
        a += 2 * Math.PI;
    return a;
}
exports.normalizeAngle = normalizeAngle;
/** Converts radians to degrees */
function radiansToDegrees(a) {
    return (a * 180) / Math.PI;
}
exports.radiansToDegrees = radiansToDegrees;
/** Converts degrees to radians */
function degreesToRadians(a) {
    return (a * Math.PI) / 180;
}
exports.degreesToRadians = degreesToRadians;
/** Creates a vector pointing in the direction angle, with the length magnitude */
function vectorFromAngle(angle, magnitude = 1) {
    return new PIXI.Point(Math.cos(angle) * magnitude, Math.sin(angle) * magnitude);
}
exports.vectorFromAngle = vectorFromAngle;
/** Returns the sum of PIXI points */
function add(...points) {
    const r = new PIXI.Point();
    for (const p of points) {
        r.x += p.x;
        r.y += p.y;
    }
    return r;
}
exports.add = add;
/** Returns the difference of PIXI points */
function subtract(...points) {
    const r = new PIXI.Point(points[0].x, points[0].y);
    for (let i = 1; i < points.length; i++) {
        r.x -= points[i].x;
        r.y -= points[i].y;
    }
    return r;
}
exports.subtract = subtract;
/** Returns the multiplication of a PIXI point by a scalar */
function multiply(a, p) {
    return new PIXI.Point(a.x * p, a.y * p);
}
exports.multiply = multiply;
/** Returns the division of a PIXI point by a scalar */
function divide(a, p) {
    return new PIXI.Point(a.x / p, a.y / p);
}
exports.divide = divide;
/** Returns a PIXI point with each element rounded down */
function floor(p) {
    return new PIXI.Point(Math.floor(p.x), Math.floor(p.y));
}
exports.floor = floor;
/** Returns a PIXI point with each element rounded */
function round(p) {
    return new PIXI.Point(Math.round(p.x), Math.round(p.y));
}
exports.round = round;
/** Returns a PIXI point that has the minimum of each component */
function min(...points) {
    const r = new PIXI.Point(Infinity, Infinity);
    for (const p of points) {
        r.x = Math.min(p.x, r.x);
        r.y = Math.min(p.y, r.y);
    }
    return r;
}
exports.min = min;
/** Returns a PIXI point that has the maximum of each component */
function max(...points) {
    const r = new PIXI.Point(-Infinity, -Infinity);
    for (const p of points) {
        r.x = Math.max(p.x, r.x);
        r.y = Math.max(p.y, r.y);
    }
    return r;
}
exports.max = max;
/** Returns true if the point p is between points min and max */
function inRectangle(p, min, max) {
    return p.x >= min.x && p.x <= max.x && p.y >= min.y && p.y <= max.y;
}
exports.inRectangle = inRectangle;
/** Takes the mean of PIXI points */
function average(...points) {
    let sum = new PIXI.Point();
    for (let point of points)
        sum = add(sum, point);
    return divide(sum, points.length);
}
exports.average = average;
/**
 Returs a point along the line between a and b, moving at a given speed.
 Will not "overshoot" b.
 */
function moveTowards(a, b, speed) {
    const d = distance(a, b);
    return lerpPoint(a, b, clamp(speed / d, 0, 1));
}
exports.moveTowards = moveTowards;
exports.moveTowardsPoint = moveTowards;
/**
 Returs an angle between a and b, turning at a given speed.
 Will not "overshoot" b.
 */
function moveTowardsAngle(a, b, speed) {
    const diff = angleBetweenAngles(a, b);
    if (diff >= 0) {
        const targetDiff = Math.min(diff, speed);
        return a + targetDiff;
    }
    else {
        const targetDiff = Math.min(-diff, speed);
        return a - targetDiff;
    }
}
exports.moveTowardsAngle = moveTowardsAngle;
/**
 Returns a number along the line between a and b, moving at a given speed.
 Will not "overshoot" b.
 */
function moveTowardsScalar(a, b, speed) {
    const d = Math.abs(b - a);
    return lerp(a, b, clamp(speed / d, 0, 1));
}
exports.moveTowardsScalar = moveTowardsScalar;
/** Returns a random number between a amd b */
function randomInRange(a, b) {
    return a + Math.random() * (b - a);
}
exports.randomInRange = randomInRange;
/** Returns a random point between a amd b, with each component considered separately */
function randomPointInRange(min, max) {
    return new PIXI.Point(randomInRange(min.x, max.x), randomInRange(min.y, max.y));
}
exports.randomPointInRange = randomPointInRange;
/* Returns true if point is within distance d of otherPoints */
function withinDistanceOfPoints(point, d, otherPoints) {
    for (const otherPoint of otherPoints) {
        if (distance(point, otherPoint) <= d)
            return true;
    }
    return false;
}
exports.withinDistanceOfPoints = withinDistanceOfPoints;
/**
 Returns a point that is a given distance away from of otherPoints.
 Warning: Could loop for a while, maybe forever!
 */
function randomPointAwayFromOthers(min, max, distanceFromPoints, existingPoints) {
    while (true) {
        const newPoint = randomPointInRange(min, max);
        if (!withinDistanceOfPoints(newPoint, distanceFromPoints, existingPoints))
            return newPoint;
    }
}
exports.randomPointAwayFromOthers = randomPointAwayFromOthers;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZ2VvbS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uL3NyYy9nZW9tLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFBQSxXQUFXOztBQUVFLFFBQUEsT0FBTyxHQUFHLEtBQUssQ0FBQztBQUNoQixRQUFBLElBQUksR0FBRyxJQUFJLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDO0FBQzVCLFFBQUEsR0FBRyxHQUFHLElBQUksSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUM7QUFFeEMseURBQXlEO0FBQ3pELFNBQWdCLEtBQUssQ0FBQyxDQUFRLEVBQUUsR0FBVSxFQUFFLEdBQVU7SUFDbEQsT0FBTyxJQUFJLENBQUMsR0FBRyxDQUFDLEdBQUcsRUFBRSxJQUFJLENBQUMsR0FBRyxDQUFDLEdBQUcsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDO0FBQzNDLENBQUM7QUFGRCxzQkFFQztBQUVELGtEQUFrRDtBQUNsRCxTQUFnQixTQUFTLENBQUMsQ0FBWTtJQUNsQyxPQUFPLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO0FBQzVDLENBQUM7QUFGRCw4QkFFQztBQUVELGtGQUFrRjtBQUNsRixTQUFnQixjQUFjLENBQUMsQ0FBWSxFQUFFLEdBQVUsRUFBRSxHQUFVO0lBQy9ELE1BQU0sR0FBRyxHQUFHLFNBQVMsQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUN6QixJQUFJLEdBQUcsR0FBRyxHQUFHLEVBQUU7UUFDWCxPQUFPLFFBQVEsQ0FBQyxDQUFDLEVBQUUsR0FBRyxHQUFHLEdBQUcsQ0FBQyxDQUFDO0tBQ2pDO1NBQU0sSUFBSSxHQUFHLEdBQUcsR0FBRyxFQUFFO1FBQ2xCLE9BQU8sUUFBUSxDQUFDLENBQUMsRUFBRSxHQUFHLEdBQUcs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